/*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#pragma once

#include <memory>
#include <ostream>

#include "BaseIRAnalyzer.h"
#include "FiniteAbstractDomain.h"
#include <boost/optional.hpp>
#include <utility>

// #include "AbstractDomain.h"
// #include "DeterminismDomain.h"
#include "DexClass.h"
#include "DexUtil.h"
#include "HashedAbstractPartition.h"
#include "HashedSetAbstractDomain.h"
#include "IRInstruction.h"
#include "PatriciaTreeMapAbstractEnvironment.h"
#include "PatriciaTreeMapAbstractPartition.h"
#include "DexClass.h"
#include "ReducedProductAbstractDomain.h"
#include <iostream>
#include "ConstantAbstractDomain.h"
#include "PatriciaTreeSetAbstractDomain.h"

using namespace sparta;

struct IntraAnalyzerParameters {
    bool track_exception = false;
};  

enum NullInputType { BOTTOM, SAT, UNSAT, TOP };



namespace nullinput {
enum class FieldType { INSTANCE, STATIC };

using std::placeholders::_1;

using StringDomain = sparta::ConstantAbstractDomain<const DexString*>;
using StringSetDomain = sparta::PatriciaTreeSetAbstractDomain<const DexString*>;
using NullInputLattice = sparta::BitVectorLattice<NullInputType, 4, std::hash<int>>;
extern NullInputLattice nullinput_lattice;
using NullInputDomain = sparta::FiniteAbstractDomain<NullInputType,
                                                       NullInputLattice,
                                                       NullInputLattice::Encoding,
                                                       &nullinput_lattice>;
using CallingContext = StringSetDomain;
using CallingContextMap =
    sparta::PatriciaTreeMapAbstractEnvironment<const IRInstruction*,
                                               CallingContext>;
// Declare a function type that summarizes the callees' analysis result
using SummaryQueryFn =
    std::function<NullInputDomain(const IRInstruction*)>;
std::ostream& operator<<(std::ostream& output,
                         const NullInputDomain& detDomain);

namespace impl {

// Forward declarations.
class Analyzer;

} // namespace impl

using namespace ir_analyzer;



class NullInputAnalysis final {
 public:
  // If we don't declare a destructor for this class, a default destructor will
  // be generated by the compiler, which requires a complete definition of
  // sra_impl::Analyzer, thus causing a compilation error. Note that the
  // destructor's definition must be located after the definition of
  // sra_impl::Analyzer.
  ~NullInputAnalysis();

explicit NullInputAnalysis(DexMethod* dex_method, IntraAnalyzerParameters ap, CallingContext* context,SummaryQueryFn* summary_query_fn = nullptr);


  StringSetDomain get_null_check_result_null() const;

  /**
   * Return a parameter type array for this invoke method instruction.
   */
  boost::optional<std::vector<DexType*>> get_method_params(
      IRInstruction* invoke_insn) const;
  /*
   * Returns the abstract object (if any) referenced by the register at the
   * given instruction. Note that if the instruction overwrites the register,
   * the abstract object returned is the value held by the register *before*
   * that instruction is executed.
   */
//   boost::optional<DeterminismDomain> get_abstract_object(
//       size_t reg, IRInstruction* insn) const;

//   boost::optional<ClassObjectSource> get_class_source(
//       size_t reg, IRInstruction* insn) const;

  CallingContextMap get_calling_context_partition() const;
  NullInputDomain get_nullinput_result() const;


 private:
  const DexMethod* m_dex_method;
  // This is the actual class that performs the analysis over the CFG
  // class Analyzer final : public BaseIRAnalyzer<AbstractObjectEnvironment> 
  // class BaseIRAnalyzer : public sparta::MonotonicFixpointIterator<cfg::GraphInterface, Domain> {
  std::unique_ptr<impl::Analyzer> m_analyzer; 
  IntraAnalyzerParameters m_ap;
};

} // namespace nullinput
